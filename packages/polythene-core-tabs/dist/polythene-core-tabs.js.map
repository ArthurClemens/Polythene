{"version":3,"file":"polythene-core-tabs.js","sources":["../../polythene-css-classes/tabs.js","../../polythene-css-classes/button.js","../src/Tabs.js","../src/ScrollButton.js","../src/Tab.js"],"sourcesContent":["import buttonClasses from \"./button\";\n\nexport default {\n  component:            \"pe-tabs\",\n\n  // elements\n  indicator:            \"pe-tabs__indicator\",\n  scrollButton:         \"pe-tabs__scroll-button\",\n  scrollButtonAtEnd:    \"pe-tabs__scroll-button-end\",\n  scrollButtonAtStart:  \"pe-tabs__scroll-button-start\",\n  tab:                  \"pe-tab\",\n  tabContent:           \"pe-tabs__tab-content\",\n  tabRow:               \"pe-tabs__row\",\n\n  // states\n  activeSelectable:     \"pe-tabs__active--selectable\",\n  isAtEnd:              \"pe-tabs--end\",\n  isAtStart:            \"pe-tabs--start\",\n  isAutofit:            \"pe-tabs--autofit\",\n  isMenu:               \"pe-tabs--menu\",\n  scrollable:           \"pe-tabs--scrollable\",\n  compactTabs:          \"pe-tabs--compact\",\n  tabHasIcon:           \"pe-tabs__tab--icon\",\n  tabRowCentered:       \"pe-tabs__row--centered\",\n  tabRowIndent:         \"pe-tabs__row--indent\",\n\n  // lookup\n  label:                buttonClasses.label\n};","\nexport default {\n  component:        \"pe-text-button\",\n  super:            \"pe-button\",\n  row:              \"pe-button-row\",\n      \n  // elements      \n  content:          \"pe-button__content\",\n  label:            \"pe-button__label\",\n  textLabel:        \"pe-button__text-label\",\n  wash:             \"pe-button__wash\",\n  washColor:        \"pe-button__wash-color\",\n  dropdown:         \"pe-button__dropdown\",\n      \n  // states      \n  border:           \"pe-button--border\",\n  contained:        \"pe-button--contained\",\n  disabled:         \"pe-button--disabled\",\n  dropdownClosed:   \"pe-button--dropdown-closed\",\n  dropdownOpen:     \"pe-button--dropdown-open\",\n  extraWide:        \"pe-button--extra-wide\",\n  hasDropdown:      \"pe-button--dropdown\",\n  highLabel:        \"pe-button--high-label\",\n  inactive:         \"pe-button--inactive\",\n  raised:           \"pe-button--raised\",\n  selected:         \"pe-button--selected\",\n  separatorAtStart: \"pe-button--separator-start\",\n  hasHover:         \"pe-button--has-hover\",\n};\n","import { filterSupportedAttributes, isTouch, subscribe, unsubscribe, isRTL } from \"polythene-core\";\nimport { scrollTo } from \"polythene-utilities\";\nimport classes from \"polythene-css-classes/tabs\";\n\nconst SCROLL_SPEED                 = 600; // px per second\nconst SCROLL_DELAY                 = .15; // seconds\nconst SCROLL_MIN_DURATION          = .5; // seconds\nconst INDICATOR_SLIDE_MIN_DURATION = .25; // seconds\n\nconst getButtons = props => {\n  return props.content\n    ? props.content\n    : props.tabs\n      ? props.tabs\n      : props.children || [];\n};\n\nconst getIndex = props => {\n  const buttons = getButtons(props);\n  const selectedIndex = Array.isArray(buttons)\n    ? buttons.reduce((acc, tab, index) => (\n      acc === undefined && !tab.disabled && tab.selected  \n        ? index\n        : acc\n    ), undefined)\n    : undefined;\n  if (selectedIndex !== undefined) {\n    return selectedIndex;\n  }\n  const attrsSelectedTabIndex = props.selectedTabIndex !== undefined\n    ? props.selectedTabIndex\n    : props.selectedTab !== undefined // deprecated\n      ? props.selectedTab\n      : undefined;\n  return attrsSelectedTabIndex !== undefined\n    ? attrsSelectedTabIndex\n    : 0;\n};\n\nconst scrollButtonGetNewIndex = (index, tabs) => {\n  const minTabIndex = 0;\n  const maxTabIndex = tabs.length - 1;\n  return {\n    backward: Math.max(index - 1, minTabIndex),\n    forward: Math.min(index + 1, maxTabIndex)\n  };\n};\n\nconst sortByLargestWidth = (a, b) =>\n  a < b\n    ? 1\n    : a > b\n      ? -1\n      : 0;\n\nexport const _Tabs = ({ h, a, getRef, useState, useEffect, ScrollButton, Tab, ...props }) => {\n  const buttons = getButtons(props);\n  if (buttons.length === 0) {\n    throw new Error(\"No tabs specified\");\n  }\n\n  const [domElement, setDomElement] = useState();\n  const [RTL, setRTL] = useState(false);\n  const tabIndex = getIndex(props) || 0;\n  const [selectedTabIndex, setSelectedTabIndex] = useState(tabIndex);\n  const [isScrollButtonAtStart, setIsScrollButtonAtStart] = useState(false);\n  const [isScrollButtonAtEnd, setIsScrollButtonAtEnd] = useState(false);\n  const [tabs, setTabs] = useState([]);\n  const [previousSelectedTabIndex, setPreviousSelectedTabIndex] = useState();\n\n  const managesScroll = props.scrollable && !isTouch;\n  const tabRowElement = domElement && domElement.querySelector(`.${classes.tabRow}`);\n  const tabIndicatorElement = domElement && domElement.querySelector(`.${classes.indicator}`);\n  const isTabsInited = !!domElement && tabs.length === buttons.length;\n\n  useEffect(\n    () => {\n      if (!tabRowElement) return;\n      const tabRowTabs = [...tabRowElement.querySelectorAll(\"[data-index]\")].map(dom => {\n        const index = parseInt(dom.getAttribute(\"data-index\"), 10);\n        return {\n          dom,\n          options: buttons[index]\n        };\n      });\n      if (tabRowTabs) {\n        setTabs(tabRowTabs);\n      }\n    },\n    [tabRowElement]\n  );\n\n  const handleScrollButtonClick = (e, direction ) => {\n    e.stopPropagation();\n    e.preventDefault();\n    const newIndex = scrollButtonGetNewIndex(selectedTabIndex, tabs)[direction];\n    if (newIndex !== selectedTabIndex) {\n      updateWithTabIndex({ index: newIndex, animate: true });\n    } else {\n      scrollToTab(newIndex);\n    }\n  };\n\n  const updateScrollButtons = () => {\n    const scrollLeft = tabRowElement.scrollLeft;\n    const minTabIndex = 0;\n    const maxTabIndex = tabs.length - 1;\n    const isAtStart = (tabRowElement.scrollLeft === 0) && (selectedTabIndex === minTabIndex);\n    const isAtEnd = (scrollLeft >= (tabRowElement.scrollWidth - domElement.getBoundingClientRect().width - 1)) && (selectedTabIndex === maxTabIndex);\n    setIsScrollButtonAtStart(isAtStart);\n    setIsScrollButtonAtEnd(isAtEnd);\n  };\n\n  const updateIndicator = ({ selectedTabElement, animate }) => {\n    if (!tabIndicatorElement) {\n      return;\n    }\n    const parentRect = domElement.getBoundingClientRect();\n    const rect = selectedTabElement.getBoundingClientRect();\n    const buttonSize = managesScroll ? rect.height : 0;\n    const translateX = RTL\n      ? rect.right - parentRect.right + tabRowElement.scrollLeft + buttonSize\n      : rect.left - parentRect.left + tabRowElement.scrollLeft - buttonSize;\n    const scaleX = 1 / (parentRect.width - 2 * buttonSize) * rect.width;\n    const transformCmd = `translate(${translateX}px, 0) scaleX(${scaleX})`;\n    const duration = animate\n      ? INDICATOR_SLIDE_MIN_DURATION\n      : 0;\n    const style = tabIndicatorElement.style;\n    style[\"transition-duration\"] = duration + \"s\";\n    style.opacity = 1;\n    style.transform = transformCmd;\n  };\n\n  const scrollToTab = tabIndex => {\n    const scroller = tabRowElement;\n    // Scroll to position of selected tab\n    const tabLeft = tabs.slice(0, tabIndex).reduce((totalWidth, tabData) =>\n      totalWidth + tabData.dom.getBoundingClientRect().width, 0);\n    // Tabs at the far right will not fully move to the left\n    // because the scrollable row will stick to the right \n    // to get the max scroll left, we subtract the visible viewport from the scroll width\n    const scrollerWidth = scroller.getBoundingClientRect().width; // frame width\n    const scrollingWidth = scroller.scrollWidth;\n    const maxScroll = scrollingWidth - scrollerWidth;\n    const left = RTL\n      ? -1 * Math.min(tabLeft, maxScroll)\n      : Math.min(tabLeft, maxScroll);\n    const currentLeft = scroller.scrollLeft;\n    if (currentLeft !== left) {\n      const duration = Math.abs(currentLeft - left) / SCROLL_SPEED;\n      const delaySeconds = SCROLL_DELAY;\n      setTimeout(() => {\n        scrollTo({\n          element: scroller,\n          to: left,\n          duration: Math.max(SCROLL_MIN_DURATION, duration),\n          direction: \"horizontal\"\n        }).then(updateScrollButtons);\n      }, delaySeconds * 1000);\n    }\n  };\n\n  const updateWithTabIndex = ({ index, animate }) => {\n    if (!tabs || !tabs.length) {\n      return;\n    }\n    setSelectedTabIndex(index);\n    const selectedTabElement = tabs[index].dom;\n    if (selectedTabElement) {\n      updateIndicator({ selectedTabElement, animate });\n    }\n    if (managesScroll) {\n      updateScrollButtons();\n    }\n    scrollToTab(index);\n    if (props.onChange) {\n      props.onChange({\n        index,\n        options: tabs[index].options,\n        el: selectedTabElement\n      });\n    }\n  };\n\n  useEffect(\n    () => {\n      if (!isTabsInited) {\n        return;\n      }\n      setRTL(isRTL({ element: domElement }));\n      \n      const redrawLargestWidth = () => {\n        if (props.largestWidth) {\n          const widths = tabs.map(({ dom }) => dom.getBoundingClientRect().width);\n          const largest = widths.sort(sortByLargestWidth)[0];\n          tabs.forEach(({ dom }) => dom.style.width = largest + \"px\");\n        }\n      };\n    \n      const redraw = () => (\n        redrawLargestWidth(),\n        updateWithTabIndex({ index: selectedTabIndex, animate: false })\n      );\n    \n      const handleFontEvent = ({ name }) =>\n        name === \"active\" || name === \"inactive\"\n          ? redraw()\n          : null;\n    \n      subscribe(\"resize\", redraw);\n      subscribe(\"webfontloader\", handleFontEvent);\n            \n      redraw();\n\n      return () => {\n        unsubscribe(\"resize\", redraw);\n        unsubscribe(\"webfontloader\", handleFontEvent);\n      };\n    },\n    [isTabsInited]\n  );\n\n  const autofit = props.scrollable || props.centered\n    ? false\n    : props.autofit\n      ? true\n      : false;\n\n  // Keep selected tab up to date\n  if (tabIndex !== undefined && previousSelectedTabIndex !== tabIndex) {\n    updateWithTabIndex({ index: tabIndex, animate: true });\n  }\n  if (previousSelectedTabIndex !== tabIndex) {\n    setPreviousSelectedTabIndex(tabIndex);\n  }\n\n  const componentProps = Object.assign(\n    {},\n    getRef(dom => dom && !domElement && (\n      setTimeout(() => setDomElement(dom), 0) // delay for Mithril 1.x\n    )),\n    filterSupportedAttributes(props),\n    props.testId && { \"data-test-id\": props.testId },\n    {\n      className: [\n        classes.component,\n        props.scrollable ? classes.scrollable : null,\n        isScrollButtonAtStart ? classes.isAtStart : null,\n        isScrollButtonAtEnd ? classes.isAtEnd : null,\n        props.activeSelected ? classes.activeSelectable : null,\n        autofit ? classes.isAutofit : null,\n        props.compact ? classes.compactTabs : null,\n        props.menu ? classes.isMenu : null,\n        props.tone === \"dark\" ? \"pe-dark-tone\" : null,\n        props.tone === \"light\" ? \"pe-light-tone\" : null,\n        props.className || props[a.class],\n      ].join(\" \")\n    }\n  );\n\n  const tabRow = buttons.map((buttonOpts = {}, index) => {\n    const buttonOptsCombined = Object.assign(\n      {},\n      buttonOpts,\n      {\n        // These options can be overridden by `all`\n        selected: index === selectedTabIndex,\n        animateOnTap: (props.animateOnTap !== false) ? true : false\n      },\n      props.all,\n      {\n        // Internal options, should not get overridden\n        index,\n        onSelect: () =>\n          updateWithTabIndex({\n            index,\n            animate: props.noIndicatorSlide\n              ? false\n              : true\n          }),\n      }\n    );\n    return h(Tab, buttonOptsCombined);\n  });\n\n  let scrollButtonAtStart = null, scrollButtonAtEnd = null;\n  if (props.scrollable) {\n    scrollButtonAtStart = h(ScrollButton, Object.assign(\n      {},\n      {\n        icon: props.scrollIconBackward,\n        className: classes.scrollButtonAtStart,\n        position: \"start\",\n        events: {\n          [a.onclick]: e => handleScrollButtonClick(e, \"backward\")\n        },\n        isRTL: RTL\n      }\n    ));\n    scrollButtonAtEnd = h(ScrollButton, Object.assign(\n      {},\n      {\n        icon: props.scrollIconForward,\n        className: classes.scrollButtonAtEnd,\n        position: \"end\",\n        events: {\n          [a.onclick]: e => handleScrollButtonClick(e, \"forward\")\n        },\n        isRTL: RTL\n      }\n    ));\n  }\n\n  const tabIndicator = props.hideIndicator\n    ? null\n    : h(\"div\",\n      {\n        className: classes.indicator\n      }\n    );\n\n  const componentContent = [\n    scrollButtonAtStart,\n    h(\"div\",\n      {\n        className: [\n          classes.tabRow,\n          props.centered ? classes.tabRowCentered : null,\n          props.scrollable ? classes.tabRowIndent : null\n        ].join(\" \")\n      },\n      [\n        ...tabRow,\n        tabIndicator\n      ]\n    ),\n    scrollButtonAtEnd,\n  ];\n\n  return h(\"div\",\n    componentProps,\n    [\n      props.before,\n      ...componentContent,\n      props.after\n    ]\n  );\n};\n","import classes from \"polythene-css-classes/tabs\";\n\nconst arrowBackward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\\\"/></svg>\";\nconst arrowForward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\\\"/></svg>\";\n\nexport const _ScrollButton = ({ h, a, IconButton, ...props }) => {\n\n  const icon = props.position === \"start\"\n    ? props.icon || { svg: { content: h.trust(props.isRTL ? arrowForward : arrowBackward) } }\n    : props.icon || { svg: { content: h.trust(props.isRTL ? arrowBackward : arrowForward) } };\n\n  const componentProps = Object.assign({}, \n    {\n      className: [\n        classes.scrollButton,\n        props.className || props[a.class]\n      ].join(\" \"),\n      icon,\n      ripple: { center: true },\n      events: props.events,\n    }\n  );\n  return h(IconButton, componentProps);\n};\n\n","import classes from \"polythene-css-classes/tabs\";\n\nexport const _Tab = ({ h, a, Button, Icon, ...props }) => {\n\n  // Let internal onclick function co-exist with passed button option\n  const events = props.events || {};\n  events[a.onclick] = events[a.onclick] || (() => {});\n\n  const componentProps = Object.assign({}, \n    props,\n    props.testId && { \"data-test-id\": props.testId },\n    {\n      \"data-index\": props.index,\n      content: h(\"div\",\n        { className: classes.tabContent },\n        [\n          props.icon ? h(Icon, props.icon) : null,\n          props.label\n            ? h(\"div\",\n              { className: classes.label },\n              h(\"span\", props.label)\n            )\n            : null,\n        ]),\n      className: [\n        classes.tab,\n        props.icon && props.label ? classes.tabHasIcon : null,\n        props.className || props[a.class],\n      ].join(\" \"),\n      selected: props.selected,\n      wash: false,\n      ripple: true,\n      events: Object.assign(\n        {},\n        events,\n        {\n          [a.onclick]: e => {\n            props.onSelect();\n            events[a.onclick](e);\n          }\n        }\n      )\n    }\n  );\n\n  const content = props.children;\n  return h(Button, componentProps, content);\n};\n"],"names":["component","indicator","scrollButton","scrollButtonAtEnd","scrollButtonAtStart","tab","tabContent","tabRow","activeSelectable","isAtEnd","isAtStart","isAutofit","isMenu","scrollable","compactTabs","tabHasIcon","tabRowCentered","tabRowIndent","label","getButtons","props","content","tabs","children","sortByLargestWidth","a","b","arrowBackward","arrowForward","h","IconButton","icon","position","svg","trust","isRTL","_extends","className","classes","join","ripple","center","events","Button","Icon","onclick","componentProps","testId","index","selected","wash","e","onSelect","getRef","useState","useEffect","ScrollButton","Tab","buttons","length","Error","domElement","setDomElement","RTL","setRTL","tabIndex","selectedIndex","Array","isArray","reduce","acc","undefined","disabled","attrsSelectedTabIndex","selectedTabIndex","selectedTab","getIndex","setSelectedTabIndex","isScrollButtonAtStart","setIsScrollButtonAtStart","isScrollButtonAtEnd","setIsScrollButtonAtEnd","setTabs","previousSelectedTabIndex","setPreviousSelectedTabIndex","managesScroll","isTouch","tabRowElement","querySelector","tabIndicatorElement","isTabsInited","tabRowTabs","_toConsumableArray","querySelectorAll","map","dom","parseInt","getAttribute","options","handleScrollButtonClick","direction","stopPropagation","preventDefault","newIndex","maxTabIndex","backward","Math","max","forward","min","scrollButtonGetNewIndex","updateWithTabIndex","animate","scrollToTab","updateScrollButtons","scrollLeft","scrollWidth","getBoundingClientRect","width","scroller","tabLeft","slice","totalWidth","tabData","scrollerWidth","maxScroll","left","currentLeft","duration","abs","setTimeout","scrollTo","element","to","then","delaySeconds","selectedTabElement","parentRect","rect","buttonSize","height","translateX","right","scaleX","transformCmd","style","opacity","transform","updateIndicator","onChange","el","redraw","largestWidth","largest","sort","forEach","redrawLargestWidth","handleFontEvent","name","subscribe","unsubscribe","autofit","centered","filterSupportedAttributes","activeSelected","compact","menu","tone","buttonOpts","buttonOptsCombined","animateOnTap","all","noIndicatorSlide","scrollIconBackward","scrollIconForward","tabIndicator","hideIndicator","componentContent","before","after"],"mappings":"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"}