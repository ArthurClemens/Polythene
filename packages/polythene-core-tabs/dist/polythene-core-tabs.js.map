{"version":3,"file":"polythene-core-tabs.js","sources":["../../polythene-css-classes/tabs.js","../../polythene-css-classes/button.js","../src/tabs.js","../src/tab.js","../src/scroll-button.js"],"sourcesContent":["import buttonClasses from \"./button\";\n\nexport default {\n  component:            \"pe-tabs\",\n\n  // elements\n  indicator:            \"pe-tabs__indicator\",\n  scrollButton:         \"pe-tabs__scroll-button\",\n  scrollButtonAtEnd:    \"pe-tabs__scroll-button-end\",\n  scrollButtonAtStart:  \"pe-tabs__scroll-button-start\",\n  tab:                  \"pe-tab\",\n  tabContent:           \"pe-tabs__tab-content\",\n  tabRow:               \"pe-tabs__row\",\n\n  // states\n  activeSelectable:     \"pe-tabs__active--selectable\",\n  isAtEnd:              \"pe-tabs--end\",\n  isAtStart:            \"pe-tabs--start\",\n  isAutofit:            \"pe-tabs--autofit\",\n  isMenu:               \"pe-tabs--menu\",\n  scrollable:           \"pe-tabs--scrollable\",\n  compactTabs:          \"pe-tabs--compact\",\n  tabHasIcon:           \"pe-tabs__tab--icon\",\n  tabRowCentered:       \"pe-tabs__row--centered\",\n  tabRowIndent:         \"pe-tabs__row--indent\",\n\n  // lookup\n  label:                buttonClasses.label\n};","\nexport default {\n  component:        \"pe-text-button\",\n  super:            \"pe-button\",\n  row:              \"pe-button-row\",\n      \n  // elements      \n  content:          \"pe-button__content\",\n  label:            \"pe-button__label\",\n  textLabel:        \"pe-button__text-label\",\n  wash:             \"pe-button__wash\",\n  dropdown:         \"pe-button__dropdown\",\n      \n  // states      \n  border:           \"pe-button--border\",\n  contained:        \"pe-button--contained\",\n  disabled:         \"pe-button--disabled\",\n  dropdownClosed:   \"pe-button--dropdown-closed\",\n  dropdownOpen:     \"pe-button--dropdown-open\",\n  extraWide:        \"pe-button--extra-wide\",\n  hasDropdown:      \"pe-button--dropdown\",\n  highLabel:        \"pe-button--high-label\",\n  inactive:         \"pe-button--inactive\",\n  raised:           \"pe-button--raised\",\n  selected:         \"pe-button--selected\",\n  separatorAtStart: \"pe-button--separator-start\",\n};\n","import { filterSupportedAttributes, isTouch, subscribe, unsubscribe, isRTL, deprecation } from \"polythene-core\";\nimport { scrollTo } from \"polythene-utilities\";\nimport classes from \"polythene-css-classes/tabs\";\n\nconst SCROLL_SPEED                 = 600; // px per second\nconst SCROLL_DELAY                 = .15; // seconds\nconst SCROLL_MIN_DURATION          = .5; // seconds\nconst INDICATOR_SLIDE_MIN_DURATION = .25; // seconds\n\nconst whenCreateDone = () => Promise.resolve();\n\nconst getButtons = vnode => {\n  const attrs = vnode.attrs;\n  return attrs.content\n    ? attrs.content\n    : attrs.tabs\n      ? attrs.tabs\n      : attrs.children || vnode.children || [];\n};\n\nconst getIndex = vnode => {\n  const buttons = getButtons(vnode);\n  const attrs = vnode.attrs;\n  const selectedIndex = Array.isArray(buttons)\n    ? buttons.reduce((acc, tab, index) => (\n      acc === undefined && !tab.disabled && tab.selected  \n        ? index\n        : acc\n    ), undefined)\n    : undefined;\n  if (selectedIndex !== undefined) {\n    return selectedIndex;\n  }\n  const attrsSelectedTabIndex = attrs.selectedTabIndex !== undefined\n    ? attrs.selectedTabIndex\n    : attrs.selectedTab !== undefined // deprecated\n      ? attrs.selectedTab\n      : undefined;\n  return attrsSelectedTabIndex !== undefined\n    ? attrsSelectedTabIndex\n    : 0;\n};\n\nconst scrollButtonGetNewIndex = (index, tabs) => {\n  const minTabIndex = 0;\n  const maxTabIndex = tabs.length - 1;\n  return {\n    backward: Math.max(index - 1, minTabIndex),\n    forward: Math.min(index + 1, maxTabIndex)\n  };\n};\n\nconst handleScrollButtonClick = (state, attrs, e, direction) => {\n  e.stopPropagation();\n  e.preventDefault();\n  const currentTabIndex = state.selectedTabIndex();\n  const newIndex = scrollButtonGetNewIndex(currentTabIndex, state.tabs)[direction];\n  if (newIndex !== currentTabIndex) {\n    setSelectedTab(state, attrs, newIndex, true);\n  } else {\n    scrollToTab(state, newIndex);\n  }\n};\n\nconst scrollToTab = (state, tabIndex) => {\n  const tabs = state.tabs;\n  const scroller = state.tabRowEl;\n  // Scroll to position of selected tab\n  const tabLeft = tabs.slice(0, tabIndex).reduce((totalWidth, tabData) =>\n    totalWidth + tabData.dom.getBoundingClientRect().width, 0);\n  // Tabs at the far right will not fully move to the left\n  // because the scrollable row will stick to the right \n  // to get the max scroll left, we subtract the visible viewport from the scroll width\n  const scrollerWidth = scroller.getBoundingClientRect().width; // frame width\n  const scrollingWidth = scroller.scrollWidth;\n  const maxScroll = scrollingWidth - scrollerWidth;\n  const left = state.isRTL\n    ? -1 * Math.min(tabLeft, maxScroll)\n    : Math.min(tabLeft, maxScroll);\n  const currentLeft = scroller.scrollLeft;\n  if (currentLeft !== left) {\n    const duration = Math.abs(currentLeft - left) / SCROLL_SPEED;\n    const delaySeconds = SCROLL_DELAY;\n    setTimeout(() => {\n      scrollTo({\n        element: scroller,\n        to: left,\n        duration: Math.max(SCROLL_MIN_DURATION, duration),\n        direction: \"horizontal\"\n      }).then(() => updateScrollButtons(state));\n    }, delaySeconds * 1000);\n  }\n};\n\nconst updateScrollButtons = state => {\n  const tabRowEl = state.tabRowEl;\n  const scrollLeft = tabRowEl.scrollLeft;\n  const currentTabIndex = state.selectedTabIndex();\n  const tabsEl = state.tabsEl;\n  const minTabIndex = 0;\n  const maxTabIndex = state.tabs.length - 1;\n  const isAtStart = (tabRowEl.scrollLeft === 0) && (currentTabIndex === minTabIndex);\n  const isAtEnd = (scrollLeft >= (tabRowEl.scrollWidth - tabsEl.getBoundingClientRect().width - 1)) && (currentTabIndex === maxTabIndex);\n  state.scrollButtonAtStart(isAtStart);\n  state.scrollButtonAtEnd(isAtEnd);\n};\n\nconst animateIndicator = (selectedTabEl, animate, state) => {\n  const parentRect = state.tabsEl.getBoundingClientRect();\n  const rect = selectedTabEl.getBoundingClientRect();\n  const buttonSize = state.managesScroll ? rect.height : 0;\n  const translateX = state.isRTL\n    ? rect.right - parentRect.right + state.tabRowEl.scrollLeft + buttonSize\n    : rect.left - parentRect.left + state.tabRowEl.scrollLeft - buttonSize;\n  const scaleX = 1 / (parentRect.width - 2 * buttonSize) * rect.width;\n  const transformCmd = `translate(${translateX}px, 0) scaleX(${scaleX})`;\n  const duration = animate\n    ? INDICATOR_SLIDE_MIN_DURATION\n    : 0;\n  const style = state.tabIndicatorEl.style;\n  style[\"transition-duration\"] = duration + \"s\";\n  style.transform = transformCmd;\n};\n\nconst setSelectedTab = (state, attrs, index, animate) => {\n  state.selectedTabIndex(index);\n  if (!state.tabs.length) return;\n  const selectedTabEl = state.tabs[index].dom;\n  if (selectedTabEl && state.tabIndicatorEl && state.tabsEl) {\n    animateIndicator(selectedTabEl, animate, state);\n  }\n  if (state.managesScroll) {\n    updateScrollButtons(state);\n  }\n  scrollToTab(state, index);\n  if (attrs.onChange) {\n    attrs.onChange({\n      index,\n      options: state.tabs[index].attrs,\n      el: selectedTabEl\n    });\n  }\n};\n\nconst sortByLargestWidth = (a, b) =>\n  a < b\n    ? 1\n    : a > b\n      ? -1\n      : 0;\n\nexport const getInitialState = (vnode, createStream) => {\n  const state = vnode.state;\n  const attrs = vnode.attrs;\n  if (attrs.selectedTab !== undefined) {\n    deprecation(\"Tabs\", { option: \"selectedTab\", newOption: \"selectedTabIndex\" });\n  }\n  const tabIndex = getIndex(vnode) || 0;\n  const selectedTabIndex = createStream(tabIndex);\n  const scrollButtonAtStart = createStream(true);\n  const scrollButtonAtEnd = createStream(true);\n  const registerTabButton = state =>\n    (index, data) => state.tabs[index] = data;\n  const registerScrollButton = state =>\n    (position, dom) => state.scrollButtons[position] = dom;\n  return {\n    tabsEl:                   undefined,\n    tabRowEl:                 undefined,\n    tabs:                     [], // {data, el}\n    tabRow:                   undefined,\n    tabIndicatorEl:           undefined,\n    selectedTabIndex,\n    previousSelectedTabIndex: undefined,\n    managesScroll:            attrs.scrollable && !isTouch,\n    scrollButtonAtStart,\n    scrollButtonAtEnd,\n    scrollButtons: {\n      start: undefined,\n      end: undefined\n    },\n    registerTabButton,\n    registerScrollButton,\n    isRTL:                    false,\n    cleanUp:                  undefined, // set in onMount\n    redrawOnUpdate:           createStream.merge([selectedTabIndex, scrollButtonAtStart, scrollButtonAtEnd])\n  };\n};\n\nexport const onMount = vnode => {\n  if (!vnode.dom) {\n    return;\n  }\n  const dom = vnode.dom;\n  const state = vnode.state;\n  const attrs = vnode.attrs;\n\n  state.tabsEl = dom;\n  state.isRTL = isRTL({ element: dom });\n  if (!attrs.hideIndicator) {\n    state.tabIndicatorEl = dom.querySelector(`.${classes.indicator}`);\n  }\n  state.tabRowEl = dom.querySelector(`.${classes.tabRow}`);\n\n  const redrawLargestWidth = () => {\n    if (state.tabs && attrs.largestWidth) {\n      const widths = state.tabs.map(tabData => tabData.dom.getBoundingClientRect().width);\n      const largest = widths.sort(sortByLargestWidth)[0];\n      state.tabs.forEach(tabData => tabData.dom.style.width = largest + \"px\");\n    }\n  };\n\n  const redraw = () => (\n    redrawLargestWidth(),\n    setSelectedTab(state, attrs, state.selectedTabIndex(), false)\n  );\n\n  const handleFontEvent = ({ name }) =>\n    name === \"active\" || name === \"inactive\"\n      ? redraw()\n      : null;\n\n  subscribe(\"resize\", redraw);\n  subscribe(\"webfontloader\", handleFontEvent);\n\n  state.cleanUp = () => (\n    unsubscribe(\"resize\", redraw),\n    unsubscribe(\"webfontloader\", handleFontEvent)\n  );\n\n  // A promise can't resolve during the oncreate loop\n  // The Mithril draw loop is synchronous - there is no delay between one this oncreate and the tab button's oncreate\n  whenCreateDone().then(redraw);\n};\n\nexport const onUnMount = ({ state }) =>\n  state.cleanUp();\n\nexport const createProps = (vnode, { keys: k }) => {\n  const state = vnode.state;\n  const attrs = vnode.attrs;\n  const autofit = attrs.scrollable || attrs.centered\n    ? false\n    : attrs.autofit\n      ? true\n      : false;\n\n  // Keep selected tab up to date\n  const index = getIndex(vnode);\n  if (index !== undefined && state.previousSelectedTabIndex !== index) {\n    setSelectedTab(state, attrs, index, true);\n  }\n  state.previousSelectedTabIndex = index;\n\n  return Object.assign(\n    {},\n    filterSupportedAttributes(attrs),\n    {\n      className: [\n        classes.component,\n        attrs.scrollable ? classes.scrollable : null,\n        state.scrollButtonAtStart() ? classes.isAtStart : null,\n        state.scrollButtonAtEnd() ? classes.isAtEnd : null,\n        attrs.activeSelected ? classes.activeSelectable : null,\n        autofit ? classes.isAutofit : null,\n        attrs.compact ? classes.compactTabs : null,\n        attrs.menu ? classes.isMenu : null,\n        attrs.tone === \"dark\" ? \"pe-dark-tone\" : null,\n        attrs.tone === \"light\" ? \"pe-light-tone\" : null,\n        attrs.className || attrs[k.class],\n      ].join(\" \")\n    }\n  );\n};\n\nexport const createContent = (vnode, { renderer: h, keys: k, Tab, ScrollButton }) => {\n  const state = vnode.state;\n  const attrs = vnode.attrs;\n\n  const buttons = getButtons(vnode);\n\n  if (buttons.length === 0) {\n    console.error(\"No tabs specified\"); // eslint-disable-line no-console\n  }\n\n  const tabRow = buttons.map((buttonOpts = {}, index) => {\n    const buttonOptsCombined = Object.assign(\n      {},\n      buttonOpts,\n      {\n        // These options can be overridden by `all`\n        selected: index === state.selectedTabIndex(),\n        animateOnTap: (attrs.animateOnTap !== false) ? true : false\n      },\n      attrs.all,\n      {\n        // Internal options, should not get overridden\n        index,\n        key: buttonOpts.key || `tab-${index}`,\n        register: state.registerTabButton(state),\n        onSelect: () =>\n          setSelectedTab(state, attrs, index, attrs.noIndicatorSlide ? false : true)\n      }\n    );\n    return h(Tab, buttonOptsCombined);\n  });\n\n  let scrollButtonAtStart, scrollButtonAtEnd;\n  if (attrs.scrollable) {\n    scrollButtonAtStart = h(ScrollButton, Object.assign(\n      {},\n      {\n        key: \"backward\",\n        icon: attrs.scrollIconBackward,\n        className: classes.scrollButtonAtStart,\n        position: \"start\",\n        register: state.registerScrollButton(state),\n        events: { [k.onclick]: e => handleScrollButtonClick(state, attrs, e, \"backward\") },\n        isRTL: state.isRTL\n      }\n    ));\n    scrollButtonAtEnd = h(ScrollButton, Object.assign(\n      {},\n      {\n        key: \"forward\",\n        icon: attrs.scrollIconForward,\n        className: classes.scrollButtonAtEnd,\n        position: \"end\",\n        register: state.registerScrollButton(state),\n        events: { [k.onclick]: e => handleScrollButtonClick(state, attrs, e, \"forward\") },\n        isRTL: state.isRTL\n      }\n    ));\n  }\n\n  const tabIndicator = attrs.hideIndicator\n    ? null\n    : h(\"div\",\n      {\n        key: \"indicator\",\n        className: classes.indicator\n      }\n    );\n\n  return [\n    attrs.scrollable ? scrollButtonAtStart : null,\n    h(\"div\",\n      {\n        key: \"tabrow\",\n        className: [\n          classes.tabRow,\n          attrs.centered ? classes.tabRowCentered : null,\n          attrs.scrollable ? classes.tabRowIndent : null\n        ].join(\" \")\n      },\n      [\n        tabRow,\n        tabIndicator\n      ]\n    ),\n    attrs.scrollable ? scrollButtonAtEnd : null\n  ];\n};","import classes from \"polythene-css-classes/tabs\";\n\n// Don't export 'element': it will be the wrapped Button component (set in polythene-xxx-tabs/tab)\n\nexport const onMount = vnode => {\n  if (!vnode.dom) {\n    return;\n  }\n  const dom = vnode.dom;\n  const attrs = vnode.attrs;\n  attrs.register(attrs.index, {\n    attrs,\n    dom\n  });\n};\n\nexport const createProps = (vnode, { renderer: h, keys: k, Icon }) => {\n  const attrs = vnode.attrs;\n  // Let internal onclick function co-exist with passed button option\n  attrs.events = attrs.events || {};\n  attrs.events[k.onclick] = attrs.events[k.onclick] || (() => {});\n  return Object.assign(\n    {},\n    attrs,\n    {\n      content: h(\"div\",\n        { className: classes.tabContent },\n        [\n          attrs.icon ? h(Icon, attrs.icon) : null,\n          attrs.label\n            ? h(\"div\",\n              { className: classes.label },\n              h(\"span\", attrs.label)\n            )\n            : null,\n        ]),\n      className: [\n        classes.tab,\n        attrs.icon && attrs.label ? classes.tabHasIcon : null,\n        attrs.className || attrs[k.class],\n      ].join(\" \"),\n      selected: attrs.selected,\n      wash: false,\n      ripple: true,\n      events: Object.assign(\n        {},\n        attrs.events,\n        {\n          [k.onclick]: e => {\n            attrs.onSelect();\n            attrs.events[k.onclick](e);\n          }\n        }\n      )\n    }\n  );\n};\n\nexport const createContent = vnode =>\n  vnode.children;\n","import classes from \"polythene-css-classes/tabs\";\n\n// Don't export 'element': it will be the wrapped IconButton component (set in polythene-xxx-tabs/scroll-button)\n\nconst arrowBackward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\\\"/></svg>\";\nconst arrowForward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\\\"/></svg>\";\n\nexport const onMount = vnode => {\n  if (!vnode.dom) {\n    return;\n  }\n  const dom = vnode.dom;\n  const attrs = vnode.attrs;\n  attrs.register(attrs.position, dom);\n};\n\nexport const createProps = (vnode, { renderer: h, keys: k }) => {\n  const attrs = vnode.attrs;\n  const icon = attrs.position === \"start\"\n    ? attrs.icon || { svg: { content: h.trust(attrs.isRTL ? arrowForward : arrowBackward) } }\n    : attrs.icon || { svg: { content: h.trust(attrs.isRTL ? arrowBackward : arrowForward) } };\n  return {\n    className: [\n      classes.scrollButton,\n      attrs.className || attrs[k.class]\n    ].join(\" \"),\n    icon,\n    ripple: { center: true },\n    events: attrs.events,\n  };\n};\n"],"names":["component","indicator","scrollButton","scrollButtonAtEnd","scrollButtonAtStart","tab","tabContent","tabRow","activeSelectable","isAtEnd","isAtStart","isAutofit","isMenu","scrollable","compactTabs","tabHasIcon","tabRowCentered","tabRowIndent","label","getButtons","vnode","attrs","content","tabs","children","getIndex","buttons","selectedIndex","Array","isArray","reduce","acc","index","undefined","disabled","selected","attrsSelectedTabIndex","selectedTabIndex","selectedTab","handleScrollButtonClick","state","e","direction","stopPropagation","preventDefault","maxTabIndex","currentTabIndex","newIndex","length","backward","Math","max","forward","min","setSelectedTab","scrollToTab","tabIndex","scroller","tabRowEl","tabLeft","slice","totalWidth","tabData","dom","getBoundingClientRect","width","scrollerWidth","maxScroll","scrollWidth","left","isRTL","currentLeft","scrollLeft","duration","abs","setTimeout","scrollTo","element","to","then","updateScrollButtons","delaySeconds","tabsEl","animate","selectedTabEl","tabIndicatorEl","parentRect","rect","buttonSize","managesScroll","height","translateX","right","scaleX","transformCmd","style","transform","animateIndicator","onChange","options","el","sortByLargestWidth","a","b","createStream","deprecation","option","newOption","previousSelectedTabIndex","isTouch","scrollButtons","start","end","registerTabButton","data","registerScrollButton","position","cleanUp","redrawOnUpdate","merge","hideIndicator","querySelector","classes","redraw","largestWidth","largest","map","sort","forEach","redrawLargestWidth","handleFontEvent","name","subscribe","unsubscribe","Promise","resolve","k","keys","autofit","centered","_extends","filterSupportedAttributes","className","activeSelected","compact","menu","tone","class","join","h","renderer","Tab","ScrollButton","console","error","buttonOpts","buttonOptsCombined","animateOnTap","all","key","register","onSelect","noIndicatorSlide","icon","scrollIconBackward","events","onclick","scrollIconForward","tabIndicator","Icon","wash","ripple","arrowBackward","arrowForward","svg","trust","center"],"mappings":"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"}