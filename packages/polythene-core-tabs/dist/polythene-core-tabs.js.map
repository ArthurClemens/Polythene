{"version":3,"file":"polythene-core-tabs.js","sources":["../../polythene-css-classes/tabs.js","../../polythene-css-classes/button.js","../src/Tabs.js","../src/ScrollButton.js","../src/Tab.js"],"sourcesContent":["import buttonClasses from \"./button\";\n\nexport default {\n  component:            \"pe-tabs\",\n\n  // elements\n  indicator:            \"pe-tabs__indicator\",\n  scrollButton:         \"pe-tabs__scroll-button\",\n  scrollButtonAtEnd:    \"pe-tabs__scroll-button-end\",\n  scrollButtonAtStart:  \"pe-tabs__scroll-button-start\",\n  tab:                  \"pe-tab\",\n  tabContent:           \"pe-tabs__tab-content\",\n  tabRow:               \"pe-tabs__row\",\n\n  // states\n  activeSelectable:     \"pe-tabs__active--selectable\",\n  isAtEnd:              \"pe-tabs--end\",\n  isAtStart:            \"pe-tabs--start\",\n  isAutofit:            \"pe-tabs--autofit\",\n  isMenu:               \"pe-tabs--menu\",\n  scrollable:           \"pe-tabs--scrollable\",\n  compactTabs:          \"pe-tabs--compact\",\n  tabHasIcon:           \"pe-tabs__tab--icon\",\n  tabRowCentered:       \"pe-tabs__row--centered\",\n  tabRowIndent:         \"pe-tabs__row--indent\",\n\n  // lookup\n  label:                buttonClasses.label\n};","\nexport default {\n  component:        \"pe-text-button\",\n  super:            \"pe-button\",\n  row:              \"pe-button-row\",\n      \n  // elements      \n  content:          \"pe-button__content\",\n  label:            \"pe-button__label\",\n  textLabel:        \"pe-button__text-label\",\n  wash:             \"pe-button__wash\",\n  dropdown:         \"pe-button__dropdown\",\n      \n  // states      \n  border:           \"pe-button--border\",\n  contained:        \"pe-button--contained\",\n  disabled:         \"pe-button--disabled\",\n  dropdownClosed:   \"pe-button--dropdown-closed\",\n  dropdownOpen:     \"pe-button--dropdown-open\",\n  extraWide:        \"pe-button--extra-wide\",\n  hasDropdown:      \"pe-button--dropdown\",\n  focus:            \"pe-button--focus\",\n  highLabel:        \"pe-button--high-label\",\n  inactive:         \"pe-button--inactive\",\n  raised:           \"pe-button--raised\",\n  selected:         \"pe-button--selected\",\n  separatorAtStart: \"pe-button--separator-start\",\n};\n","import { filterSupportedAttributes, isTouch, subscribe, unsubscribe, isRTL } from \"polythene-core\";\nimport { scrollTo } from \"polythene-utilities\";\nimport classes from \"polythene-css-classes/tabs\";\n\nconst SCROLL_SPEED                 = 600; // px per second\nconst SCROLL_DELAY                 = .15; // seconds\nconst SCROLL_MIN_DURATION          = .5; // seconds\nconst INDICATOR_SLIDE_MIN_DURATION = .25; // seconds\n\nconst getButtons = props => {\n  return props.content\n    ? props.content\n    : props.tabs\n      ? props.tabs\n      : props.children || [];\n};\n\nconst getIndex = props => {\n  const buttons = getButtons(props);\n  const selectedIndex = Array.isArray(buttons)\n    ? buttons.reduce((acc, tab, index) => (\n      acc === undefined && !tab.disabled && tab.selected  \n        ? index\n        : acc\n    ), undefined)\n    : undefined;\n  if (selectedIndex !== undefined) {\n    return selectedIndex;\n  }\n  const attrsSelectedTabIndex = props.selectedTabIndex !== undefined\n    ? props.selectedTabIndex\n    : props.selectedTab !== undefined // deprecated\n      ? props.selectedTab\n      : undefined;\n  return attrsSelectedTabIndex !== undefined\n    ? attrsSelectedTabIndex\n    : 0;\n};\n\nconst scrollButtonGetNewIndex = (index, tabs) => {\n  const minTabIndex = 0;\n  const maxTabIndex = tabs.length - 1;\n  return {\n    backward: Math.max(index - 1, minTabIndex),\n    forward: Math.min(index + 1, maxTabIndex)\n  };\n};\n\nconst sortByLargestWidth = (a, b) =>\n  a < b\n    ? 1\n    : a > b\n      ? -1\n      : 0;\n\nexport const _Tabs = ({ h, a, getRef, useState, useEffect, ScrollButton, Tab, ...props }) => {\n  const buttons = getButtons(props);\n  if (buttons.length === 0) {\n    throw new Error(\"No tabs specified\");\n  }\n\n  const [domElement, setDomElement] = useState();\n  const [RTL, setRTL] = useState(false);\n  const tabIndex = getIndex(props) || 0;\n  const [selectedTabIndex, setSelectedTabIndex] = useState(tabIndex);\n  const [isScrollButtonAtStart, setIsScrollButtonAtStart] = useState(false);\n  const [isScrollButtonAtEnd, setIsScrollButtonAtEnd] = useState(false);\n  const [tabs, setTabs] = useState([]);\n  const [previousSelectedTabIndex, setPreviousSelectedTabIndex] = useState();\n\n  const managesScroll = props.scrollable && !isTouch;\n  const tabRowElement = domElement && domElement.querySelector(`.${classes.tabRow}`);\n  const tabIndicatorElement = domElement && domElement.querySelector(`.${classes.indicator}`);\n  const isTabsInited = !!domElement && tabs.length === buttons.length;\n\n  useEffect(\n    () => {\n      if (!tabRowElement) return;\n      const tabRowTabs = [...tabRowElement.querySelectorAll(\"[data-index]\")].map(dom => {\n        const index = parseInt(dom.getAttribute(\"data-index\"), 10);\n        return {\n          dom,\n          options: buttons[index]\n        };\n      });\n      if (tabRowTabs) {\n        setTabs(tabRowTabs);\n      }\n    },\n    [tabRowElement]\n  );\n\n  const handleScrollButtonClick = (e, direction ) => {\n    e.stopPropagation();\n    e.preventDefault();\n    const newIndex = scrollButtonGetNewIndex(selectedTabIndex, tabs)[direction];\n    if (newIndex !== selectedTabIndex) {\n      updateWithTabIndex({ index: newIndex, animate: true });\n    } else {\n      scrollToTab(newIndex);\n    }\n  };\n\n  const updateScrollButtons = () => {\n    const scrollLeft = tabRowElement.scrollLeft;\n    const minTabIndex = 0;\n    const maxTabIndex = tabs.length - 1;\n    const isAtStart = (tabRowElement.scrollLeft === 0) && (selectedTabIndex === minTabIndex);\n    const isAtEnd = (scrollLeft >= (tabRowElement.scrollWidth - domElement.getBoundingClientRect().width - 1)) && (selectedTabIndex === maxTabIndex);\n    setIsScrollButtonAtStart(isAtStart);\n    setIsScrollButtonAtEnd(isAtEnd);\n  };\n\n  const updateIndicator = ({ selectedTabElement, animate }) => {\n    if (!tabIndicatorElement) {\n      return;\n    }\n    const parentRect = domElement.getBoundingClientRect();\n    const rect = selectedTabElement.getBoundingClientRect();\n    const buttonSize = managesScroll ? rect.height : 0;\n    const translateX = RTL\n      ? rect.right - parentRect.right + tabRowElement.scrollLeft + buttonSize\n      : rect.left - parentRect.left + tabRowElement.scrollLeft - buttonSize;\n    const scaleX = 1 / (parentRect.width - 2 * buttonSize) * rect.width;\n    const transformCmd = `translate(${translateX}px, 0) scaleX(${scaleX})`;\n    const duration = animate\n      ? INDICATOR_SLIDE_MIN_DURATION\n      : 0;\n    const style = tabIndicatorElement.style;\n    style[\"transition-duration\"] = duration + \"s\";\n    style.opacity = 1;\n    style.transform = transformCmd;\n  };\n\n  const scrollToTab = tabIndex => {\n    const scroller = tabRowElement;\n    // Scroll to position of selected tab\n    const tabLeft = tabs.slice(0, tabIndex).reduce((totalWidth, tabData) =>\n      totalWidth + tabData.dom.getBoundingClientRect().width, 0);\n    // Tabs at the far right will not fully move to the left\n    // because the scrollable row will stick to the right \n    // to get the max scroll left, we subtract the visible viewport from the scroll width\n    const scrollerWidth = scroller.getBoundingClientRect().width; // frame width\n    const scrollingWidth = scroller.scrollWidth;\n    const maxScroll = scrollingWidth - scrollerWidth;\n    const left = RTL\n      ? -1 * Math.min(tabLeft, maxScroll)\n      : Math.min(tabLeft, maxScroll);\n    const currentLeft = scroller.scrollLeft;\n    if (currentLeft !== left) {\n      const duration = Math.abs(currentLeft - left) / SCROLL_SPEED;\n      const delaySeconds = SCROLL_DELAY;\n      setTimeout(() => {\n        scrollTo({\n          element: scroller,\n          to: left,\n          duration: Math.max(SCROLL_MIN_DURATION, duration),\n          direction: \"horizontal\"\n        }).then(updateScrollButtons);\n      }, delaySeconds * 1000);\n    }\n  };\n\n  const updateWithTabIndex = ({ index, animate }) => {\n    if (!tabs.length) {\n      return;\n    }\n    setSelectedTabIndex(index);\n    const selectedTabElement = tabs[index].dom;\n    if (selectedTabElement) {\n      updateIndicator({ selectedTabElement, animate });\n    }\n    if (managesScroll) {\n      updateScrollButtons();\n    }\n    scrollToTab(index);\n    if (props.onChange) {\n      props.onChange({\n        index,\n        options: tabs[index].options,\n        el: selectedTabElement\n      });\n    }\n  };\n\n  useEffect(\n    () => {\n      if (!isTabsInited) {\n        return;\n      }\n      setRTL(isRTL({ element: domElement }));\n      \n      const redrawLargestWidth = () => {\n        if (props.largestWidth) {\n          const widths = tabs.map(({ dom }) => dom.getBoundingClientRect().width);\n          const largest = widths.sort(sortByLargestWidth)[0];\n          tabs.forEach(({ dom }) => dom.style.width = largest + \"px\");\n        }\n      };\n    \n      const redraw = () => (\n        redrawLargestWidth(),\n        updateWithTabIndex({ index: selectedTabIndex, animate: false })\n      );\n    \n      const handleFontEvent = ({ name }) =>\n        name === \"active\" || name === \"inactive\"\n          ? redraw()\n          : null;\n    \n      subscribe(\"resize\", redraw);\n      subscribe(\"webfontloader\", handleFontEvent);\n            \n      redraw();\n\n      return () => {\n        unsubscribe(\"resize\", redraw);\n        unsubscribe(\"webfontloader\", handleFontEvent);\n      };\n    },\n    [isTabsInited]\n  );\n\n  const autofit = props.scrollable || props.centered\n    ? false\n    : props.autofit\n      ? true\n      : false;\n\n  // Keep selected tab up to date\n  if (tabIndex !== undefined && previousSelectedTabIndex !== tabIndex) {\n    updateWithTabIndex({ index: tabIndex, animate: true });\n  }\n  if (previousSelectedTabIndex !== tabIndex) {\n    setPreviousSelectedTabIndex(tabIndex);\n  }\n\n  const componentProps = Object.assign(\n    {},\n    getRef(dom => dom && !domElement && (\n      setDomElement(dom)\n    )),\n    filterSupportedAttributes(props),\n    props.testId && { \"data-test-id\": props.testId },\n    {\n      className: [\n        classes.component,\n        props.scrollable ? classes.scrollable : null,\n        isScrollButtonAtStart ? classes.isAtStart : null,\n        isScrollButtonAtEnd ? classes.isAtEnd : null,\n        props.activeSelected ? classes.activeSelectable : null,\n        autofit ? classes.isAutofit : null,\n        props.compact ? classes.compactTabs : null,\n        props.menu ? classes.isMenu : null,\n        props.tone === \"dark\" ? \"pe-dark-tone\" : null,\n        props.tone === \"light\" ? \"pe-light-tone\" : null,\n        props.className || props[a.class],\n      ].join(\" \")\n    }\n  );\n\n  const tabRow = buttons.map((buttonOpts = {}, index) => {\n    const buttonOptsCombined = Object.assign(\n      {},\n      buttonOpts,\n      {\n        // These options can be overridden by `all`\n        selected: index === selectedTabIndex,\n        animateOnTap: (props.animateOnTap !== false) ? true : false\n      },\n      props.all,\n      {\n        // Internal options, should not get overridden\n        index,\n        key: buttonOpts.key || `tab-${index}`,\n        onSelect: () =>\n          updateWithTabIndex({\n            index,\n            animate: props.noIndicatorSlide\n              ? false\n              : true\n          })\n      }\n    );\n    return h(Tab, buttonOptsCombined);\n  });\n\n  let scrollButtonAtStart = null, scrollButtonAtEnd = null;\n  if (props.scrollable) {\n    scrollButtonAtStart = h(ScrollButton, Object.assign(\n      {},\n      {\n        key: \"backward\",\n        icon: props.scrollIconBackward,\n        className: classes.scrollButtonAtStart,\n        position: \"start\",\n        events: {\n          [a.onclick]: e => handleScrollButtonClick(e, \"backward\")\n        },\n        isRTL: RTL\n      }\n    ));\n    scrollButtonAtEnd = h(ScrollButton, Object.assign(\n      {},\n      {\n        key: \"forward\",\n        icon: props.scrollIconForward,\n        className: classes.scrollButtonAtEnd,\n        position: \"end\",\n        events: {\n          [a.onclick]: e => handleScrollButtonClick(e, \"forward\")\n        },\n        isRTL: RTL\n      }\n    ));\n  }\n\n  const tabIndicator = props.hideIndicator\n    ? null\n    : h(\"div\",\n      {\n        key: \"indicator\",\n        className: classes.indicator\n      }\n    );\n\n  return h(\"div\",\n    componentProps,\n    [\n      props.before,\n      scrollButtonAtStart,\n      h(\"div\",\n        {\n          key: \"tabrow\",\n          className: [\n            classes.tabRow,\n            props.centered ? classes.tabRowCentered : null,\n            props.scrollable ? classes.tabRowIndent : null\n          ].join(\" \")\n        },\n        [\n          tabRow,\n          tabIndicator\n        ]\n      ),\n      scrollButtonAtEnd,\n      props.after\n    ]\n  );\n};","import classes from \"polythene-css-classes/tabs\";\n\nconst arrowBackward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\\\"/></svg>\";\nconst arrowForward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\\\"/></svg>\";\n\nexport const _ScrollButton = ({ h, a, IconButton, ...props }) => {\n\n  const icon = props.position === \"start\"\n    ? props.icon || { svg: { content: h.trust(props.isRTL ? arrowForward : arrowBackward) } }\n    : props.icon || { svg: { content: h.trust(props.isRTL ? arrowBackward : arrowForward) } };\n\n  const componentProps = Object.assign({}, \n    {\n      className: [\n        classes.scrollButton,\n        props.className || props[a.class]\n      ].join(\" \"),\n      icon,\n      ripple: { center: true },\n      events: props.events,\n    }\n  );\n  return h(IconButton, componentProps);\n};\n\n","import classes from \"polythene-css-classes/tabs\";\n\nexport const _Tab = ({ h, a, Button, Icon, ...props }) => {\n\n  // Let internal onclick function co-exist with passed button option\n  const events = props.events || {};\n  events[a.onclick] = events[a.onclick] || (() => {});\n\n  const componentProps = Object.assign({}, \n    props,\n    props.testId && { \"data-test-id\": props.testId },\n    {\n      \"data-index\": props.index,\n      content: h(\"div\",\n        { className: classes.tabContent },\n        [\n          props.icon ? h(Icon, props.icon) : null,\n          props.label\n            ? h(\"div\",\n              { className: classes.label },\n              h(\"span\", props.label)\n            )\n            : null,\n        ]),\n      className: [\n        classes.tab,\n        props.icon && props.label ? classes.tabHasIcon : null,\n        props.className || props[a.class],\n      ].join(\" \"),\n      selected: props.selected,\n      wash: false,\n      ripple: true,\n      events: Object.assign(\n        {},\n        events,\n        {\n          [a.onclick]: e => {\n            props.onSelect();\n            events[a.onclick](e);\n          }\n        }\n      )\n    }\n  );\n\n  const content = props.children;\n  return h(Button, componentProps, content);\n};\n"],"names":["component","indicator","scrollButton","scrollButtonAtEnd","scrollButtonAtStart","tab","tabContent","tabRow","activeSelectable","isAtEnd","isAtStart","isAutofit","isMenu","scrollable","compactTabs","tabHasIcon","tabRowCentered","tabRowIndent","label","getButtons","props","content","tabs","children","sortByLargestWidth","a","b","arrowBackward","arrowForward","h","getRef","useState","useEffect","ScrollButton","Tab","buttons","length","Error","domElement","setDomElement","RTL","setRTL","tabIndex","selectedIndex","Array","isArray","reduce","acc","index","undefined","disabled","selected","attrsSelectedTabIndex","selectedTabIndex","selectedTab","getIndex","setSelectedTabIndex","isScrollButtonAtStart","setIsScrollButtonAtStart","isScrollButtonAtEnd","setIsScrollButtonAtEnd","setTabs","previousSelectedTabIndex","setPreviousSelectedTabIndex","managesScroll","isTouch","tabRowElement","querySelector","classes","tabIndicatorElement","isTabsInited","tabRowTabs","_toConsumableArray","querySelectorAll","map","dom","parseInt","getAttribute","options","handleScrollButtonClick","e","direction","stopPropagation","preventDefault","newIndex","maxTabIndex","backward","Math","max","forward","min","scrollButtonGetNewIndex","updateWithTabIndex","animate","scrollToTab","updateScrollButtons","scrollLeft","scrollWidth","getBoundingClientRect","width","scroller","tabLeft","slice","totalWidth","tabData","scrollerWidth","maxScroll","left","currentLeft","duration","abs","setTimeout","scrollTo","element","to","then","delaySeconds","selectedTabElement","parentRect","rect","buttonSize","height","translateX","right","scaleX","transformCmd","style","opacity","transform","updateIndicator","onChange","el","isRTL","redraw","largestWidth","largest","sort","forEach","redrawLargestWidth","handleFontEvent","name","subscribe","unsubscribe","autofit","centered","componentProps","_extends","filterSupportedAttributes","testId","className","activeSelected","compact","menu","tone","class","join","buttonOpts","buttonOptsCombined","animateOnTap","all","key","onSelect","noIndicatorSlide","icon","scrollIconBackward","position","events","onclick","scrollIconForward","tabIndicator","hideIndicator","before","after","Button","Icon","wash","ripple","IconButton","svg","trust","center"],"mappings":"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"}